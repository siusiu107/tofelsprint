Passage 0060: Consensus Protocols and Why Replicated Logs Need Majorities and Terms (Computer Science)
======================================================================================================
(Word count: 633)

A modern application rarely runs on a single machine. Databases replicate across servers;
web services scale horizontally; and critical state—who paid, who reserved a seat, which
sensor reading is accepted—must remain consistent even when hardware fails. The difficulty
is that distributed systems do not fail politely. A machine can pause, a network link can
drop packets, and a rack can lose power, leaving different computers with different views of
“what happened.” Achieving consensus—agreement on a sequence of events—therefore becomes a
central problem in building reliable services.

One intuition is to appoint a leader. If one node is responsible for ordering commands,
followers can apply that order and remain consistent. Leader-based consensus protocols make
this intuition precise by combining three ideas: an elected leader, a replicated log of
commands, and rules for when an entry is considered committed. The leader receives client
requests, appends them to its log, and sends the new entries to followers. Followers
acknowledge receipt. Once an entry is stored on a majority of nodes, it is considered
committed and can be applied to the state machine. [A] Majority commitment matters because
it ensures that any future majority will overlap with the committed majority, preserving the
entry even if leadership changes.

Elections, however, are tricky under unreliable communication. If a leader becomes
unreachable, followers must decide whether it has failed or is merely slow. Because waiting
forever is not an option, nodes use timeouts: if a follower does not hear from a leader
within a randomized interval, it becomes a candidate and asks others to vote. Randomization
reduces the chance that multiple candidates start simultaneously, which would split votes.
Yet split votes still happen, especially in networks with variable delays. In that case, the
system may have to retry elections until one candidate gathers a majority.

Log replication raises its own hazards. Suppose a leader appends an entry and sends it to
some followers, then crashes before the entry is committed. A new leader may be elected that
does not contain the uncommitted entry. If the old leader later returns, the system must
prevent it from overwriting committed history. Protocols handle this by attaching terms
(logical epochs) to entries and by requiring leaders to prove they are up to date. [B]
Followers reject leaders whose logs are missing committed entries, and leaders overwrite
conflicting uncommitted entries so that logs converge on the same prefix.

From a distance, these rules can look like bureaucracy, yet they encode a physical truth:
networks create partial knowledge. A client might receive a “success” response from a leader
that then crashes before replication completes, creating a mismatch between the client’s
belief and the cluster’s durable state. Well-designed systems therefore distinguish between
acceptance and commitment and structure client responses accordingly. Some systems wait to
respond until commitment; others respond early but provide mechanisms to reconcile later.
The choice is a trade-off among latency, throughput, and the cost of reconciliation.

Even when consensus is correct, performance can be surprising. A majority requirement means
that if two nodes are down in a five-node cluster, progress can halt. Moreover, slow disks
can bottleneck the leader, because replication is ultimately an I/O problem. Engineers
mitigate these limits with batching, pipelining, and snapshotting: periodically compacting
the log into a state snapshot so new nodes do not replay years of history. Yet snapshots
must be coordinated with the log so that the same state is reconstructed everywhere.

Consensus protocols are sometimes described as “making many machines behave like one.” [C]
More precisely, they make many machines agree on a narrative of events, even when the world
provides contradictory fragments. [D] The achievement is not that failures disappear, but
that, through careful rules about majorities, terms, and commitment, disagreement is forced
to shrink until one history remains.


Questions
---------

1. [Vocabulary] The word “committed” in the passage is closest in meaning to:
   A. durably accepted as part of the agreed log after replication to a majority
   B. sent to a client once but not stored anywhere
   C. deleted from memory to save space
   D. a type of ocean density interface

2. [Factual] According to the passage, why is majority commitment important in leader-based consensus?
   A. Any future majority overlaps with the committed majority, helping preserve entries across leader changes
   B. It guarantees that networks never drop packets
   C. It allows entries to be committed without being stored on any node
   D. It prevents the need for elections entirely

3. [Sentence Insert] Where would the following sentence best fit?
   Sentence to insert: That overlap property is what turns a fragile message into a durable cluster decision.
   A. [A]
   B. [B]
   C. [C]
   D. [D]

4. [Inference] What can be inferred about why timeouts are randomized during elections?
   A. To reduce simultaneous candidacies that would split votes and delay leader selection
   B. To ensure every election takes exactly the same amount of time
   C. To allow leaders to commit entries without replication
   D. To prevent any node from ever becoming a candidate

5. [Negative Factual] All of the following are mentioned as engineering techniques to improve performance EXCEPT:
   A. batching and pipelining
   B. snapshotting to compact history
   C. randomized timeouts for elections
   D. malic acid storage in vacuoles

6. [Rhetorical Purpose] Why does the author describe consensus as agreeing on a “narrative of events”?
   A. To emphasize that nodes must converge on one ordered history despite partial and conflicting observations
   B. To claim that consensus protocols are fictional stories with no rules
   C. To argue that state machines should ignore logs entirely
   D. To suggest that clients should always accept uncommitted success responses

7. [Reference] In the passage, “these rules” refers to the protocol mechanisms involving:
   A. terms, log up-to-dateness checks, and overwriting conflicting uncommitted entries so logs converge
   B. chemical reactions that yellow perovskite films
   C. geochemical signatures in volcanic glass
   D. internal tides generated at ridges

8. [Organization] How is the passage primarily organized?
   A. It introduces the consensus problem, explains leader-based log replication and commitment, then discusses elections, crash scenarios, client semantics, and performance trade-offs
   B. It lists programming languages used in databases
   C. It focuses only on client-side UI design
   D. It argues that distributed systems never fail

9. [Paraphrase] Which option best restates the idea that systems distinguish acceptance from commitment?
   A. A node may receive an entry, but it is treated as durable only after it is replicated and confirmed under the protocol’s rules
   B. Acceptance and commitment are identical, so early responses are always safe
   C. Entries become committed only when written in a printed diagram
   D. Commitment occurs when a client tells a story about the request

10. [Summary] Which statement best summarizes the passage?
   A. Consensus protocols work mainly by eliminating network failures and making machines perfectly synchronized.
   B. The passage explains why distributed systems need consensus, describes leader-based replicated logs with majority commitment, shows how elections and terms handle crashes and conflicting histories, and notes practical trade-offs involving client responses, availability, and performance techniques such as snapshotting.
   C. Majority rules are unnecessary because one machine can always dictate history even after failures.
   D. Consensus is solved solely by faster hardware and does not require protocol design.


Answer Key
----------
1: A
2: A
3: A
4: A
5: D
6: A
7: A
8: A
9: A
10: B